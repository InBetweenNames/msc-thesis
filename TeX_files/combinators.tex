\documentclass[../main.tex]{subfiles}

\begin{document}

\chapter{Parser Combinators}

\section{Handling non-referentially transparent functions}

The parser combinators as described in this Thesis differ from their original implementations
in \cite{frosthafiz2008}.  The most significant change that we made is that the combinators are now {\em monadic} in nature rather than being strictly pure functions.
By modifying the parser to work with monadic rather than pure values, the restriction that the semantics themselves must also be pure was lifted, and
\texttt{unsafeDupablePerformIO} is no longer needed to ``trick'' the type system into accepting a function is referentially transparent.

The parser works in the IO monad currently, however if other monads were desired, only minimal changes would be required to the parser in order to accommodate
other instances of the Monad typeclass.  In the chapter {\em Future Work}, one potential application of this functionality is discussed.


\section{Summary of the Parser Combinators}

Aside from the differences noted above, the combinators function the same as they did originally in \cite{frosthafiz2008}.  They are summarized as follows:

\begin{itemize}
	\item \texttt{(<|>)} -- a combinator that represents an alternative.  In the expression ``\texttt{a <|> b}'', first matching \texttt{a} would be tried, and if that parse failed, then matching \texttt{b} would be tried.
	\item \texttt{(*>)} -- a combinator that represents a sequence.  In the expression ``\texttt{a *> b}'', the parser would try to match \texttt{a} followed by \texttt{b}.  Both must be matched in order for the parse to succeed.
\end{itemize}

\end{document}