\documentclass[../main.tex]{subfiles}

\begin{document}
	
\setlength{\abovedisplayskip}{0pt}
\setlength{\belowdisplayskip}{12pt}
\setlength{\abovedisplayshortskip}{0pt}
\setlength{\belowdisplayshortskip}{0pt} 

\chapter {Event-Based Denotational Semantics}

\label{chapter:semantics}

\section{Event-Based Triplestores}

One problem with entity-based triplestores is that it is difficult to add contextual information to a triple.  Two common examples of contextual information are time and location.  Many approaches that allow this use a method called {\em reification}\cite{antoniou2004semantic}. %TODO: Explain reification?

One form of reification is to organize information into {\em events}.

\begin{definition}[Event]
	A set of meaningfully connected physical phenomena occurring in a span of time
\end{definition}

For example, the triple \texttt{(sally, met, susan)} in an entity-based triplestore could be represented by three triples:

\begin{code}
	(event1, type, meet)
	(event1, subject, sally)
	(event1, object, susan)
\end{code}

These triples describe the event in which ``Sally met Susan'' rather than directly describing the meeting itself.  The advantage of this approach is that it is possible to add additional information about the meeting by simply adding more triples with \texttt{event1} as the {\em subject}:

\begin{code}
	(event1, year, 1955)
	(event1, location, windsor)
\end{code}

Triplestores that organize their information in this fashion are called {\em Event-based Triplestores}.

\begin{definition}[Event-Based Triplestore]
	A triplestore where the \texttt{subject} of the triples contained within it refer to Events\cite{frostagboola2014}
\end{definition}

We say that a triple {\em belongs} to an event if the \texttt{subject} of the triple is the name of the event.  For example,
the triples above belong to \texttt{event1}.  The entities that belong to an event \texttt{e} are the \texttt{objects} of the triples belonging to that event.
For example, in the triples above, the entities \texttt{sally}, \texttt{susan}, \texttt{1955}, and \texttt{windsor} belong to \texttt{event1}.

The key motivation behind using Event-based triplestores in this Thesis is that they directly support reification on triples\cite{frostagboola2014}.

\section{Original Event-Based Denotational Semantics}

The semantics in this Thesis is based on work that was originally described in \cite{frost2013event}.  That work was later improved upon in \cite{frostagboola2014}.

One key feature of the original semantics is that they were not tied to any particular implementation of an event-based triplestore,
removing the need to directly convert queries into corresponding triplestore queries.
This was achieved by defining the semantic functions in terms of an abstract triplestore {\em interface}.
The original semantic functions themselves were defined in pure math notation, suitable for implementation in any sufficiently powerful programming language.

In \cite{frostagboola2014}, a Miranda implementation of the semantics was demonstrated, and in \cite{frost2014denotational} a Haskell
implementation was produced as well.  In both the Miranda and Haskell versions, the sets used in the semantics were represented using
singly-linked lists, called {\em lists}.  Lists are composed using the \texttt{(:)} operator, where the left argument of \texttt{(:)} is an element
and the right argument is a list.  The \texttt{(:)} operator is {\em right-associative} prepends the left operand to the right operand.  The empty list is denoted with
\texttt{[]}.  The syntax \texttt{[x\_1, x\_2, ... x\_n]}, \texttt{(x\_1 : x\_2 : ... : x\_n : [])} and \texttt{(x\_1 : (x\_2 : ... : (x\_n : [])))} are equivalent.
Lists are homogeneous in that types of all elements in the list must be identical.

A summary of the original semantics and the Haskell implementation is provided below:

\subsection{Triplestore interface}

Triplestore access was implemented for in-program triplestores through the following functions, where
\texttt{ev\_data} is an in-program triplestore represented as a list of 3-tuples, each 3-tuple representing a triple:

\begin{code}
  getts_1 ("?",b,c)   = [x | (x,y,z) <- ev_data, y == b, z == c]
  getts_2 (a,"?",c)   = [x | (x,y,z) <- ev_data, x == a, z == c]
  getts_3 (a,b,"?")   = [z | (x,y,z) <- ev_data, x == a, y == b]
\end{code}

Other useful utility triplestore functions were defined in terms of the \texttt{getts\_*}
functions:

\begin{code}
  get_subj_for_ev ev       = getts_3 (ev,  "subject","?")
  get_subjs_for_events evs = concatMap (get_subj_for_event evs)
	
  get_members set = get_subjs_for_evs evs
  where
    evs = intersect evs_of_type_membership evs_with_set_as_object
    evs_of_type_membership   = getts_1 ("?", "type", "membership")
    evs_with_set_as_object   = getts_1 ("?",  "object",  set)
		
  get_subjs_of_event_type et  = get_subjs_for_evs evs
  where
    evs = getts_1 ("?",  "type",  et)
\end{code}

\subsection{Semantic functions}

Common nouns were defined as ``the set of entities that are members of the set associated with that noun''\cite{frost2014denotational}.
These were implemented using the \texttt{get\_members} function.

%NOTE: Should the code examples be rewritten to not use anything from \cite{frost2014denotational}?
\begin{code}
	person = get_members "person"
\end{code}

Intransitive verbs were defined as ``the set of entities that are subjects of an event of the type associated with that verb''\cite{frost2014denotational}.
They were implemented using the \texttt{get\_subjs\_of\_event\_type} function.

\begin{code}
	steal = get_subjs_of_event_type "steal_ev"
\end{code}

Proper nouns were defined as ``functions that take a set of entities as an
argument and which return True if a particular entity is a member of that
set''\cite{frost2014denotational}.  They were implemented using the
\texttt{member} function which tests list membership.

\begin{code}
	torrio setofents  = "torrio" `member` setofents
\end{code}

Determiners were defined as functions taking two sets of entities, called
a nounphrase and verbphrase respectively.  Each of these functions
is defined in terms of set intersection.  They were implemented using
list intersection:

\begin{code}
  a     nph vbph     = length (intersect nph vbph) /= 0
  one   nph vbph     = length (intersect nph vbph)  == 1
  two   nph vbph     = length (intersect nph vbph)  == 2
  every nph vbph     = subset  nph vbph
\end{code}

Conjoiners for common nouns were implemented similarly:

\begin{code}
  nounand s t  = intersect s t
  nounor  s t  = mkset (s ++ t) -- behaves like set union
  that         = nounand
\end{code}


A {\em determiner phrase} was defined as being a determiner with a common noun applied to it\cite{frost2014denotational}.
A {\em termphrase} was defined as being either a a proper noun or a determiner phrase\cite{frost2014denotational}.
Conjoiners for termphrases were implemented differently:
\vspace{1em}
\begin{code}
 termand tmph1 tmph2 setofents = (tmph1 setofents) && (tmph2 setofevs)
 termor  tmph1 tmph2 setofents = (tmph1 setofents) || (tmph2 setofevs)
\end{code}
\vspace{1em}
This was necessary because common nouns were sets of entities, but
proper nouns and determiner phrases were functions that acted on sets
of entities.

Transitive verbs were defined in terms of {\em images}\cite{frost2014denotational}.  Briefly, images
are constructed from binary relations with the \texttt{collect} function.

\begin{definition}[Collect function]
The function collect is defined such that it takes a binary relation as an
argument, joinrel, and ``returns a new binary relation, containing one binary tuple
(x, image\_x) for each member of the projection of the left-hand column of joinrel
, where image\_x is the mathematical image of x under the relation joinrel''\cite{frost2014denotational}
\end{definition}

\begin{definition}[Image (original semantics)]
  A function that maps elements in the domain to sets
\end{definition}

Intuitively speaking, the \texttt{collect} function converts arbitrary binary
relations into functions.  $\forall x$ All pairs $(x, y_1), (x, y_2), ..., (x,
y_n)$ are grouped into one pair $(x, \left\{y_1, y_2, ..., y_n\right\})$ in the new binary
relation.

In the Haskell implementation, binary relations and images were represented using {\em association
lists}, which are lists of pairs\cite{frost2014denotational}.

\texttt{collect} was implemented as follows:

\begin{code}
	collect [] = []
	collect ((x,y):t) = (x, y:[e2 |(e1, e2)<-t,e1 == x])
		: collect [(e1, e2) | (e1, e2) <- t, e1 /= x ]
\end{code}

According to \cite{agboola2015extensible}, this implementation of \texttt{collect} has a worst-case asymptotic time complexity of
O$(n^2)$.

\begin{definition}[Entity-event relation]
  A binary relation from entities in a triplestore to events in that triplestore
\end{definition}

The function \texttt{make\_image} creates an entity-event relation from a given event type and then converts it to an image using \texttt{collect}:

\begin{code}
  make_image et = collect
    [(subj, ev) | ev <- evs, subj <- getts_3 (ev, "subject","?") ]
	  where evs = getts_1 ("?", "type",  et)
\end{code}

Transitive verbs were defined by {\em filtering} pairs in the image of the event
type that corresponds to the verb using the termphrase provided.  The only pairs remaining in the image are those
for which the termphrase predicate returns \texttt{True}.  An example is the
``join'' verb:

\begin{code}
  join tmph = [subj | (subj, evs) <- make_image "join_ev",
       tmph (concat [getts_3 (ev,  "object", "?") | ev <- evs])]
\end{code}

Prepositional phrases were defined through an extension of the above
mechanism.  Before passing an entity list to a termphrase, the events
those entities were drawn from would be first filtered through a series
of prepositions.

Prepositions were defined as a pair consisting of the name of a property
of an event and a termphrase.  Chained prepositional phrases were defined
as a list of prepositions.

An example chained prepositional phrase: \texttt{[("with\_implement", a
telescope), ("year", year "1877")]}

\texttt{join} could be modified to support prepositions as follows:

\begin{code}
  joinâ€™ tmph preps = [subj | (subj, evs) <- make_image "join_ev", 
    tmph (concat [getts_3 (ev,"object","?") | ev <- evs,
      filter_ev ev preps])]
\end{code}

where \texttt{filter\_ev} is defined as follows\cite{frost2014denotational}:

\begin{code}
  filter_ev ev [] = True
  filter_ev ev (prep:list_of_preps)
    = ((snd (prep)) (getts_3 (ev,fst (prep),"?")))
        && filter_ev ev list_of_preps
\end{code}

\subsection{Haskell implementation for SPARQL}

Later, in \cite{agboola2015extensible}, the Haskell implementation was modified
to support SPARQL endpoints, with some efficiency improvements.  In particular, the asymptotic time complexity of the \texttt{collect} function was improved to O$(n$ log $n)$ time.

\section{Improvements over Original Semantics}

In the following section, {\em function currying}\cite{currying} is used to simplify the description of the semantics.
Briefly, a function $f$ with $n$ arguments can be {\em curried} into a chain of $n$ functions, each accepting one argument and returning the next function
in a chain, effectively ``fixing'' the current argument in the returned function.  If the end of the chain is reached, the value that $f$
would have produced had it been directly called with all $n$ arguments is returned.  This is a key feature of many functional programming languages\cite{haskell}.

We use the syntax $f$ $x_1$ $x_2$ $\dots$ $x_n$ to denote a function or function call with $n$ arguments.  If this syntax is used
and only a partial number of arguments are provided, then a function of the remaining arguments is returned.  Otherwise,
this syntax is equivalent to $f(x_1, x_2, \dots, x_n)$.

The improvements from the original semantics presented in
\cite{frost2014demonstration}\cite{frostagboola2014} are detailed below.

\subsection{Multiple-property prepositions and terminology}

Prepositions were previously defined as a pair consisting of the name of a property of an event and a termphrase.  This meant that prepositions could
only refer to one property of an event, making prepositions such as ``in''
impossible to express, as it could refer to either a location or a range in time.
To solve this, we extended the definition of preposition in our semantics.  First, some new terminology:

\begin{definition}[Property]
	A \texttt{predicate} of a triple in an event-based triplestore.
\end{definition}

For example, in the triple \texttt{(event1000, with\_implement, refractor\_telescope\_1)}, \texttt{with\_implement} is a property.  Since the triple belongs to \texttt{event1000}, we say that \texttt{with\_implement} is a property of \texttt{event1000}.  In general, there is no restriction on the number of entities of an event that share the same property.

\begin{definition}[Preposition]
	A pair consisting of a set of properties and a predicate.
\end{definition}

By using a set of properties rather than a single property as in the original semantics, we are able to support prepositions that could refer to multiple properties.
For example, the preposition \texttt{in'} in our semantics is defined as:

\begin{equation*}
	\mathtt{in'} \  \mathtt{tmph} = \left(\left\{\text{``\texttt{location}''}, \text{``\texttt{year}''}\right\}, \mathtt{tmph}\right)
\end{equation*}

When referring to the entities with property \texttt{prop} of an event, we are referring to the \texttt{objects} of the triples of the event that have the predicate \texttt{prop}.
We may use the phrase ``the \texttt{prop}s of an event'' as a shorthand for ``the entities with property \texttt{prop} of an event''.
For example, the \texttt{subjects}, \texttt{objects}, or \texttt{types} of an event are the entities with property \texttt{subject}, \texttt{object} or \texttt{type} of that event, respectively.

\subsection{Naming and definition of ``Images''}

Originally, transitive verbs were defined in terms of {\em images}\cite{frost2014denotational}.
In this Thesis, we use the term {\em function defined by the relation} instead of {\em image}, as {\em image} is a term that already exists throughout mathematics and has
a different meaning.

\begin{definition}[Function defined by the relation $r$]
	The function defined by the binary relation $r$ is the set $\{(\mathtt{x}, \mathtt{image_x}) : \mathtt{x}$ is a member of the domain of $\mathtt{r} \ \wedge \  \mathtt{image_x}$ is the image of $\mathtt{x}$ under $\mathtt{r} \}$
\end{definition}

%TODO: Move Haskell impl details to chapter 5
The function defined by a relation is referred to throughout this thesis by the shorthand {\em FDBR}.  It is represented with an association list in the Haskell code,
as {\em images} were represented in the original semantics.  The function defined by the relation $r$ is denoted with the syntax $\mathtt{FDBR}(\mathtt{r})$.
We call an element $\mathtt{(x, image_x)}$ of an FDBR an {\em FDBR-pair}.

We also define the \texttt{ENTEVPROP} relation.  Informally, $\mathtt{ENTEVPROP}(\mathtt{evs}, \mathtt{prop})$ is the entity-event relation in which the \texttt{prop}s of the events \texttt{evs} are related to the events that they belong to.

\begin{definition}[\texttt{ENTEVPROP(evs, prop)} relation]
	\[\mathtt{ENTEVPROP}(\mathtt{evs}, \mathtt{prop}) = \{(\mathtt{ent}, \mathtt{ev}) : \mathtt{ent} \in \mathtt{getts}(\mathtt{ev}, \mathtt{prop}, \mathtt{ANY}) \ \wedge \ \mathtt{ev} \in \mathtt{evs} \}\]
\end{definition}

The {\em ENTEVPROP\_TYPE} relation is similar, accepting an event type as an argument instead of a set of events.
{\em ENTEVPROP\_TYPE}$(ev\_type, prop)$ obtains the set of events where the \texttt{type}s of those events are the desired event type.


\begin{definition}[\texttt{ENTEVPROP\_TYPE(ev\_type, prop)} relation]
	\begin{multline*}
	\mathtt{ENTEVPROP\_TYPE}(\mathtt{ev\_type}, \mathtt{prop}) = \mathtt{ENTEVPROP}(\mathtt{evs}, \mathtt{prop}) \\ \mathtt{where} \ \mathtt{evs} = \mathtt{getts}(\mathtt{ANY}, \mathtt{type}, \mathtt{ev\_type})
	\end{multline*}
\end{definition}

In the original semantics, the \texttt{make\_trans} function could be defined as:

\begin{multline*}
  \mathtt{make\_trans} \ \mathtt{event\_type}\ \mathtt{tmph} = \\ \mathtt{tmph} (\mathtt{map} \ \mathtt{fst}\ \mathtt{FDBR}(\mathtt{ENTEVPROP\_TYPE}(\mathtt{event\_type}, \text{``\texttt{subject}''})))
\end{multline*}

These relations form the basis on which our new semantics are defined.

\subsection{The implicit `and' problem and the problem of `every'}

In the original semantics there were two problems with how prepositional phrases were implemented.

First, a query such as ``the sun is orbited by every planet'' would have returned \texttt{False} due to the way \texttt{filter\_ev} was implemented.

This was because in $\mathtt{FDBR}(\mathtt{orbit\_})$, where $\mathtt{orbit\_}\ =\ \mathtt{ENTEVPROP\_TYPE}(\mathtt{orbit\_ev},\allowbreak \text{``\texttt{object}''})$, the FDBR-pair for \texttt{sun} would have the form: $(\mathtt{sun}, [\mathtt{event1000}, \mathtt{event1001} , \allowbreak \dots , \mathtt{event1008} ])$, where each event would denote a separate \texttt{orbit} event corresponding to each planet that orbits the sun.  \texttt{filter\_ev} applied each preposition's termphrase to each event separately, meaning that no information provided by other events could be used by the predicate.  Hence \texttt{every planet} would have returned \texttt{False} for each individual event's associated \texttt{object}, and \texttt{filter\_ev} would have discarded the pair for \texttt{sun} in $FDBR($\texttt{orbit\_}$)$.  If there were one singular orbit event in which all of the planets were listed as orbiting the sun, then this query would have worked.  However, if there are properties unique to the planets being described in each orbit event, then it is not possible to describe all orbits in one singular event.  Therefore there was a need for a method to filter events in FDBRs that allowed termphrases to view the objects of {\em all} events in an FBDR-pair rather than just one.  

Second, an implicit ``and'' was placed in between each preposition, transforming sentences such as ``who discovered something with two telescopes in 1914'' into ``who discovered something with two telescopes and in 1914''.

Although the above sentence is ambiguous in that it could be asking whether someone used two telescopes to discover one particular object, or whether
someone discovered potentially different objects with two telescopes, the asker most certainly did not intend for an implicit ``and'' to be inserted in between the prepositions.
The reason this happens is because in the original \texttt{filter\_ev} function, the sets of events were not actually ``honed down'' before being passed to subsequent predicates in the preposition chain.

In our semantics we define a new \texttt{filter\_ev} function that overcomes
both these problems.  Its definition is deferred until the {\em Transitive Verbs}
section below as some additional concepts must be introduced first.

\subsection{Semantic consistency}

One goal of the new semantics is to unify concepts in the original semantics.  A significant refactoring was done in order to 
accomplish this task.

\subsubsection{Triplestore utility functions}

The \texttt{getts} functions are identical to how they were in\cite{frost2013event}, however
all other triplestore utility functions have been modified from their original definitions.
In particular, the functions \texttt{get\_subjs\_for\_event}, \texttt{get\_subjs\_for\_events},
\texttt{get\_subjs\_for\_event\_type}, and \texttt{get\_members} return an FDBR rather than a set of entities.  They are defined as follows:

\begin{multline*}
  \mathtt{get\_subjs\_for\_events}\enspace \mathtt{evs} = \mathtt{FDBR}(\mathtt{ENTEVPROP}(\mathtt{evs}, \text{``\texttt{subject}''})) \\
  \mathtt{get\_subjs\_for\_event}\enspace \mathtt{ev} = \mathtt{get\_subjs\_for\_events}\left\{\mathtt{ev}\right\} \\
  \mathtt{get\_subjs\_for\_event\_type}\enspace \mathtt{ev\_type} =\\ \mathtt{FDBR}(\mathtt{ENTEVPROP\_TYPE}(\mathtt{ev\_type}, \text{``\texttt{subject}''}))
\end{multline*}

The definition of \texttt{get\_members} is identical to the original except that it uses the new \texttt{get\_subjs\_for\_events} function.

By returning FDBRs, information about the entire entity-event relation is provided rather than only information about entities
belonging to those events.  This change simplifies the definitions of the triplestore utility functions and also makes their function
more uniform.


\subsubsection{Semantic functions}

All semantic functions have been modified to accept FDBRs and return FDBRs, with the exception of ``query'' functions
\texttt{whatobj}, \texttt{where'}, \texttt{how'}, \texttt{when'}, and \texttt{what}.

\texttt{what} and \texttt{whatobj} are differentiated to obtain the \texttt{subjects} and \texttt{objects} of FDBRs, respectively, with the
\texttt{objects} being obtained through the events in FDBR. 

\paragraph{Determiner phrases and proper nouns}
Previously, predicates were functions from sets of entities to boolean values.

In our new semantics, we modified the definition of predicates such that predicates accept FDBRs and return FDBRs.
A returned FDBR that is non-empty is considered to be \texttt{True}.  A returned FDBR that is empty is considered to be \texttt{False}.
Specifically, a predicate $p$ evaluated on an FDBR $F$ returns only the elements of $F$ that are {\em relevant} to $p$.

\begin{definition}[Relevant and irrelevant FDBR-pairs with respect to a predicate]
	An FDBR-Pair $x$ of an FDBR $F$ is {\em irrelevant} with respect to a predicate $p$ if $p\ F = p\ F'$, where $F'$ is obtained by removing $x$ from $F$.  Otherwise,
	$x$ is {\em relevant} to $p$.
\end{definition}

\begin{definition}[Predicate]
	A function from FDBRs to FDBRs that discards irrelevant FDBR-pairs from its argument.
\end{definition}

Most predicates in our semantics are defined in terms of the function \texttt{intersect\_fdbr}:

\begin{definition}[intersect\_fdbr function]
	\begin{multline*}
	\mathtt{intersect\_fdbr}\enspace \mathtt{fdbr1}\enspace \mathtt{fdbr2} = \\ \{\mathtt{(ent2, evs2) : (ent1, evs1) }\in \mathtt{fdbr1 \ \wedge\ (ent2, evs2) } \in \mathtt{fdbr2\ \wedge\ ent1 = ent2}\}
	\end{multline*}
\end{definition}

Briefly, this function performs the intersection of two FDBRs using the entity name in each FDBR-pair.  The events from the second FDBR are preserved
in the intersection, while the events from the first FDBR are discarded.

For an example of why \texttt{intersect\_fdbr} is defined this way, consider the sentence
\texttt{a moon spins}.  The events that {\em justify} the claim that a particular moon spins are contained in the FDBR \texttt{spins}.  On the other hand, the events of \texttt{moon}
are only membership events and don't contribute any useful information about whether a given moon will spin or not.  Therefore we would expect in the FDBR for \texttt{a moon spins},
we would only have events from the \texttt{spins} relation.  Furthermore, it wouldn't make sense to have any entities that weren't moons in \texttt{a moon spins}, nor would
it make sense for us to be missing any moons, since we know that all moons spin.  If we let $\mathtt{a} = \mathtt{intersect\_fdbr}$, then we capture exactly these semantics.

In general, in any determiner function, we are interested in the events of the second FDBR as they provide {\em justification} that the entities in the first FDBR
have some characteristic that the second FDBR expresses.  The first FDBR is useful only for the entities contained within it as a way of specifying which entities should be queried.
With this in mind, we define the determiners as follows:\\
{\setlength{\mathindent}{0cm}
\allowdisplaybreaks
\begin{gather*}
\mathtt{a} = \mathtt{intersect\_fdbr} \\
\mathtt{any} = \mathtt{a} \\
\mathtt{the} = \mathtt{a}  \\
\mathtt{some} = \mathtt{a}   \\
\mathtt{an} = \mathtt{a}   \\
\mathtt{every} =
\begin{cases}
	\mathtt{intersect\_fdbr}\enspace \mathtt{nph}\enspace \mathtt{vbph},\ \mathtt{if}\enspace \mathtt{nph\_entities}\ \subseteq\ \mathtt{vbph\_entities} \\
	\mathtt{\emptyset},\ \mathtt{otherwise}
\end{cases} \\
\mathtt{\indent where} \\
\mathtt{\indent\indent nph\_entities} = \mathtt{map}\enspace \mathtt{fst}\enspace \mathtt{nph} \\
\mathtt{\indent\indent vbph\_entities} = \mathtt{map}\enspace \mathtt{fst}\enspace \mathtt{vbph} \\
\mathtt{one}\enspace \mathtt{nph}\enspace \mathtt{vbph} =
\begin{cases}
	\mathtt{intersect\_fdbr}\enspace \mathtt{nph}\enspace \mathtt{vbph},\ \mathtt{if}\ \left\vert\mathtt{intersect\_fdbr}\enspace \mathtt{nph}\enspace \mathtt{vbph}\right\vert = 1 \\
	\emptyset,\ \mathtt{otherwise}
\end{cases} \\
\mathtt{two}\enspace \mathtt{nph}\enspace \mathtt{vbph} =
\begin{cases}
\mathtt{intersect\_fdbr}\enspace \mathtt{nph}\enspace \mathtt{vbph},\ \mathtt{if}\ \left\vert\mathtt{intersect\_fdbr}\enspace \mathtt{nph}\enspace \mathtt{vbph}\right\vert = 2 \\
\emptyset,\ \mathtt{otherwise}
\end{cases} \\
\end{gather*}
}

\texttt{fst} is a function that returns the first component from in a pair.  The \texttt{map} function computes the image of a function $f$ over the elements of a set $s$.  
Hence the function \texttt{map fst} obtains all of the entities in an FDBR.

Proper nouns are defined as follows:

\begin{gather*}
\mathtt{make\_pnoun}\enspace \mathtt{noun}\enspace \mathtt{fdbr} = \mathtt{intersect\_fdbr}\enspace \left\{(\mathtt{noun}, \mathtt{\emptyset})\right\} \enspace\mathtt{fdbr}
\end{gather*}

Note that proper nouns are treated the same as determiners under the same reasoning.

This change was actually motivated by our changes to how prepositional phrases are handed in our semantics, and is the basis through which
``filtering'' occurs along preposition chains.  Since predicates only return FDBR-pairs that are relevant to them, \texttt{filter\_ev} can directly
use predicates to filter FDBRs and find the events that are common among all of them, if any.

\paragraph{Transitive verbs}
\label{par:transitive}

In the original semantics, the function \texttt{make\_trans} was used to
construct an FDBR out of an event type.

In our semantics, we distinguish between the active and passive voices of transitive verbs.  For example, in the sentence ``Hall discovered a moon'', the active voice is being used.
In the sentence ``A moon was discovered by Hall'', the passive voice is being
used.  This voice of a verb changes what the verb is acting on in  a sentence.  To express this in the semantics,
we provide two functions, \texttt{make\_trans\_active'} and \texttt{make\_trans\_passive'} to construct an FDBR denoting the active and passive voice of a transitive verb, respectfully.\\
{\setlength{\mathindent}{0cm}
\begin{gather*}
\mathtt{make\_trans\_active'}\enspace \mathtt{ev\_type}\enspace \mathtt{tmph}\enspace \mathtt{preps} = \\
	\mathtt{\indent filter}\enspace \bigg(\mathtt{prepFilter}\enspace \Big(\{(\{\text{``\texttt{object}''}\}, \mathtt{tmph})\} \cup \mathtt{preps}\Big)\bigg)\enspace \bigg(\mathtt{fdbr\_active}\bigg) \\
\mathtt{make\_trans\_passive'}\enspace \mathtt{ev\_type}\enspace \mathtt{preps} = \\
	\mathtt{\indent filter}\enspace (\mathtt{prepFilter}\enspace \mathtt{preps})\enspace (\mathtt{fdbr\_passive}) \\
\mathtt{ where} \\
\mathtt{\indent prepFilter} ((\_, \mathtt{evs})) = \mathtt{filter\_ev}\enspace \mathtt{preps}\enspace \mathtt{evs} \\
\mathtt{\indent fdbr\_active} = \mathtt{FDBR}(\mathtt{ENTEVPROP\_TYPE}(\mathtt{ev\_type}, \text{``\texttt{subject}''})) \\
\mathtt{\indent fdbr\_passive} = \mathtt{FDBR}(\mathtt{ENTEVPROP\_TYPE}(\mathtt{ev\_type}, \text{``\texttt{object}''}))
\end{gather*}
}

The \texttt{filter} function takes a function that returns a boolean value and returns a new set containing only the elements of the original set for which that function returned \texttt{True}.
\texttt{filter\_ev} is used to filter FDBRs such that only FDBR-pairs that match
the prepositions are kept. It is defined as follows:\\

{\setlength{\mathindent}{0cm}
\begin{gather*}
\mathtt{filter\_ev}\enspace \mathtt{preps}\enspace \mathtt{evs} =
\begin{cases}
\mathtt{False},\ \mathtt{if}\enspace \mathtt{filtered} = \mathtt{\emptyset} \\
\mathtt{True},\ \mathtt{otherwise}
\end{cases} \\
\mathtt{\indent where} \\
\mathtt{\indent\indent filtered} = \left\{ \mathtt{ev} : \left( \forall \mathtt{propFDBR} \in
\mathtt{propertyFDBRs} \right)\ \mathtt{ev} \in (\mathtt{snd}\enspace \mathtt{propFDBR}) \right\}  \\
\begin{split}
\mathtt{\indent\indent propertyFDBRs} = \left\{ \mathtt{pred}\left(\bigcup_{\mathtt{pName} \in \mathtt{propNames}} \mathtt{FDBR}(\mathtt{ENTEVPROP}(\mathtt{evs}, \mathtt{pName})) \right) : \right. \\
\left. (\mathtt{propNames}, \mathtt{pred}) \in \mathtt{preps} \vphantom{\bigcup_{\mathtt{pName} \in \mathtt{propNames}}} \right\}
\end{split}
\end{gather*}
}

Informally, \texttt{filter\_ev} computes an FDBR of the relevant properties for
each preposition from all events, and evaluates the termphrases of each
preposition on each corresponding FDBR.  The intersections of all events in all
FDBRs are used as a way
of ``honing down'' the events.  If there are no events in common with any
preposition, then the return value is \texttt{False}, otherwise at least
one event satisfies all prepositions and the return value is \texttt{True}.
This solves the problems with how prepositional phrases were handled in the
original semantics.

We also provide two more functions, \texttt{make\_trans\_active} and \texttt{make\_trans\_passive}, transitive verbs without prepositional phrases:

\begin{gather*}
\mathtt{make\_trans\_active}\enspace \mathtt{ev\_type}\enspace \mathtt{tmph} = \mathtt{make\_trans\_active'}\enspace \mathtt{ev\_type}\enspace \mathtt{tmph}\enspace \mathtt{\emptyset}\\
\mathtt{make\_trans\_passive}\enspace \mathtt{ev\_type} = \mathtt{make\_trans\_passive'}\enspace \mathtt{ev\_type}\enspace \emptyset
\end{gather*}

The mechanism for filtering prepositional phrases is powerful enough that no extra work need be done for handling the termphrase associated with a transitive verb, for example
\texttt{a moon} in \texttt{discover (a moon)}.  By adding a {\em
virtual preposition} to the set of prepositions, \texttt{(\{(\{"object"\},
tmph)\}}, \texttt{filter\_ev} is able to subsume that functionality, simplifying
the semantics.

Therefore, both voices of transitive verbs, and versions both with and without support for prepositional phrases, are handled uniformly and transparently.

\paragraph{Adjectives, common nouns, and intransitive verbs}

In the original semantics, intransitive verbs and common nouns were defined as a set of entities.

Since \texttt{get\_subjs\_of\_event\_type} and \texttt{get\_members} return
FDBRs, intransitive verbs and common nouns in our semantics are denoted by FDBRs.
In addition, we also support adjectives in our semantics. 
Adjectives were not demonstrated in the original semantics, however are easily accommodated using the \texttt{intersect\_fdbr} function.

For example: ``vacuumous moon'', where \texttt{vacuumous} is an adjective
and \texttt{moon} is a common noun, can be accomodated with
\texttt{vacuumous `intersect\_fdbr` moon}.


\paragraph{Conjoiners}

Originally, conjoiners for common nouns were defined in terms of the intersections and unions
of sets of entities.  In our semantics, conjoiners for common nouns are defined in terms
of FDBRs.

\begin{gather*}
    \mathtt{nounand} = \mathtt{intersect\_fdbr} \\
    \mathtt{nounor}\enspace \mathtt{nph1}\enspace \mathtt{nph2} = \mathtt{nph1} \cup \mathtt{nph2} \\
    \mathtt{that} = \mathtt{nounand}
\end{gather*}

Similarly, the conjoiners for termphrases are also defined in terms of FDBRs:

\begin{gather*}
  \mathtt{termand}\enspace \mathtt{tmph1}\enspace \mathtt{tmph2}\enspace \mathtt{fdbr} = \\ \indent\indent
  \begin{cases}
    \mathtt{termor}\enspace \mathtt{tmph1}\enspace \mathtt{tmph2}\enspace \mathtt{fdbr},\ \mathtt{if} \enspace \left(\mathtt{tmph1}\enspace \mathtt{fdbr} \cup
    \mathtt{tmph2}\enspace \mathtt{fdbr}\right) \neq \mathtt{\emptyset} \\
    \emptyset,\ \mathtt{otherwise}
  \end{cases} \\
  \mathtt{termor}\enspace \mathtt{tmph1} \enspace \mathtt{tmph2} \enspace \mathtt{fdbr} = \mathtt{nounor}\enspace (\mathtt{tmph1}\enspace \mathtt{fdbr}) \enspace (\mathtt{tmph2} \enspace \mathtt{fdbr})
\end{gather*}

Note that \texttt{termand tmph1 tmph2} and \texttt{termor tmph1 tmph2} are predicates: they are functions from FDBRs to FDBRs and return exactly the FDBR-pairs
that are relevant to them.  \texttt{termand tmph1 tmph2} is curiously defined in terms of \texttt{termor}.  The reason for this is that, provided both termphrases
evaluate to \texttt{True} for FDBR $F$, all FDBR-pairs in both FDBRs are relevant: if any of those FDBR-pairs were to go missing from $F$, calling this new FDBR $F'$, at least one of 
the termphrases would evaluate to \texttt{False} on $F'$, changing the result.

\subsection{The use of `by' as a preposition}

One item of note is that in our semantics we treat the word ``by'', as in ``discovered by'', as a preposition.

When designing the new semantics orginally, the termphrase after ``by'' was
applied to a passive transitive verb in order to filter FDBR-pairs for those matching
the termphrase.  However, this is exactly the same task that \texttt{filter\_ev} already performs when evaluating chains of prepositional phrases.
By letting \texttt{by tmph = (\{"subject"\}, tmph)}, we can include \texttt{by}
directly in chains of prepositional phrases as a {\em virtual preposition}, simplifying the grammar
with no loss of functionality.  With this approach, ``by'' can appear anywhere in a chain of prepositions, for example ``in 1877 by hall'', instead
of needing to be directly next to the verb.

\end{document}
