\documentclass[../main.tex]{subfiles}

\begin{document}

\chapter {Event-Based Denotational Semantics}

\section{Event-Based Triplestores}

One problem with entity-based triplestores is that it is difficult to add contextual information to a triple.  Two common examples of contextual information are time and location.  Many approaches that allow this use a method called {\em reification} \cite{?}.

One form of reification is to organize information into {\em events}.

\begin{definition}[Event]
	A point in time and the physical occurrences that are associated with it \cite{?} -- TODO: find better definition
\end{definition}

For example, the triple \texttt{(sally, met, susan)} in an entity-based triplestore could be represented by three triples:

\begin{code}
	(event1, type, meet)
	(event1, subject, sally)
	(event1, object, susan)
\end{code}

These triples describe the event in which ``Sally met Susan'' rather than directly describing the meeting itself.  The advantage of this approach is that it is possible to add additional information about the meeting by simply adding more triples with \texttt{event1} as the {\em subject}:

\begin{code}
	(event1, year, 1955)
	(event1, location, windsor)
\end{code}

Triplestores that organize their information in this fashion are called {\em Event-based Triplestores}.

\begin{definition}[Event-Based Triplestore]
	A triplestore where the \texttt{subject} of the triples contained within it refer to Events\cite{frostagboola2014}
\end{definition}

We say that a triple {\em belongs} to an event if the \texttt{subject} of the triple is the name of the event.  For example,
the triples above belong to \texttt{event1}.  The entities that belong to an event \texttt{e} are the \texttt{objects} of the triples belonging to that event.
For example, in the triples above, the entities \texttt{sally}, \texttt{susan}, \texttt{1955}, and \texttt{windsor} belong to \texttt{event1}.

The key motivation behind using Event-based triplestores in this Thesis is that they directly support reification on triples\cite{frostagboola2014}.

\section{Original Event-Based Denotational Semantics}

The semantics in this Thesis is based on work that was originally described in \cite{frost2013event}.  That work was later improved upon in \cite{frostagboola2014}.

One key feature of the original semantics is that they were not tied to any particular implementation of an event-based triplestore,
removing the need to directly convert queries into corresponding triplestore queries.
This was achieved by defining the semantic functions in terms of an abstract triplestore {\em interface}.
The original semantic functions themselves were defined in pure math notation, suitable for implementation in any sufficiently powerful programming language.

In \cite{frostagboola2014}, a Miranda implementation of the semantics was demonstrated, and in \cite{frost2014denotational} a Haskell
implementation was produced as well.  In both the Miranda and Haskell versions, the sets used in the semantics were represented using
singly-linked lists, called {\em lists}.  Lists are composed using the \texttt{(:)} operator, where the left argument of \texttt{(:)} is an element
and the right argument is a list.  The \texttt{(:)} operator is {\em right-associative} prepends the left operand to the right operand.  The empty list is denoted with
\texttt{[]}.  The syntax \texttt{[x\_1, x\_2, ... x\_n]}, \texttt{(x\_1 : x\_2 : ... : x\_n : [])} and \texttt{(x\_1 : (x\_2 : ... : (x\_n : [])))} are equivalent.
Lists are homogeneous in that types of all elements in the list must be identical.

A summary of the original semantics and the Haskell implementation is provided below:

\subsection{Triplestore interface}

Triplestore access was implemented for in-program triplestores through the following functions, where
\texttt{ev\_data} is an in-program triplestore represented as a list of 3-tuples, each 3-tuple representing a triple:

\begin{code}
	getts_1 ("?",b,c)   = [x | (x,y,z) <- ev_data, y == b, z == c]
	getts_2 (a,"?",c)   = [x | (x,y,z) <- ev_data, x == a, z == c]
	getts_3 (a,b,"?")   = [z | (x,y,z) <- ev_data, x == a, y == b]
\end{code}

Other useful utility triplestore functions were defined in terms of the \texttt{getts\_*}
functions:

\begin{code}
	get_subj_for_ev ev       = getts_3 (ev,  "subject","?")
	get_subjs_for_events evs = concatMap (get_subj_for_event evs)
	
	get_members set = get_subjs_for_evs evs
	where
		evs = intersect evs_of_type_membership evs_with_set_as_object
		evs_of_type_membership   = getts_1 ("?", "type", "membership")
		evs_with_set_as_object   = getts_1 ("?",  "object",  set)
		
	get_subjs_of_event_type et  = get_subjs_for_evs evs
	where
		evs = getts_1 ("?",  "type",  et)
\end{code}

\subsection{Semantic functions}

Common nouns were defined as ``the set of entities that are members of the set associated with that noun'' \cite{frost2014denotational}.
These were implemented using the \texttt{get\_members} function.

%NOTE: Should the code examples be rewritten to not use anything from \cite{frost2014denotational}?
\begin{code}
	person = get_members "person"
\end{code}

Intransitive verbs were defined as ``the set of entities that are subjects of an event of the type associated with that verb'' \cite{frost2014denotational}.
They were implemented using the \texttt{get\_subjs\_of\_event\_type} function.

\begin{code}
	steal = get_subjs_of_event_type "steal_ev"
\end{code}

Proper nouns were defined as ``functions that take a set of entities as an
argument and which return True if a particular entity is a member of that
set''\cite{frost2014denotational}.  They were implemented using the
\texttt{member} function which tests list membership.

\begin{code}
	torrio setofents  = "torrio" `member` setofents
\end{code}

Determiners were defined as functions taking two sets of entities, called
a nounphrase and verbphrase respectively.  Each of these functions
is defined in terms of set intersection.  They were implemented using
list intersection:

\begin{code}
  a     nph vbph     = length (intersect nph vbph) /= 0
  one   nph vbph     = length (intersect nph vbph)  == 1
  two   nph vbph     = length (intersect nph vbph)  == 2
  every nph vbph     = subset  nph vbph
\end{code}

Conjoiners for common nouns were implemented similarly:

\begin{code}
  nounand s t  = intersect s t
  nounor  s t  = mkset (s ++ t) -- behaves like set union
  that         = nounand
\end{code}


A {\em determiner phrase} was defined as being a determiner with a common noun applied to it \cite{frost2014denotational}.
A {\em termphrase} was defined as being either a a proper noun or a determiner phrase \cite{frost2014denotational}.
Conjoiners for termphrases were implemented differently:

\begin{code}
  termand tmph1 tmph2 setofents =  (tmph1 setofents) && (tmph2 setofevs)
  termor  tmph1 tmph2 setofents =  (tmph1 setofents) || (tmph2 setofevs)
\end{code}

This was necessary because common nouns were sets of entities, but
proper nouns and determiner phrases were functions that acted on sets
of entities.

Transitive verbs were defined in terms of {\em images} \cite{frost2014denotational}.  Briefly, images
are constructed from binary relations with the \texttt{collect} function.

\begin{definition}[Collect function]
The function collect is defined such that it takes a binary relation as an
argument, joinrel, and ``returns a new binary relation, containing one binary tuple
(x, image\_x) for each member of the projection of the left-hand column of joinrel
, where image\_x is the mathematical image of x under the relation joinrel'' \cite{frost2014denotational}
\end{definition}

\begin{definition}[Image]
  A function that maps elements in the domain to sets
\end{definition}

Intuitively speaking, the \texttt{collect} function converts arbitrary binary
relations into functions.  $\forall x$ All pairs $(x, y_1), (x, y_2), ..., (x,
y_n)$ are grouped into one pair $(x, {y_1, y_2, ..., y_n})$ in the new binary
relation.

In the Haskell implementation, binary relations and images were represented using {\em association
lists}, which are lists of pairs\cite{frost2014denotational}.

\texttt{collect} was implemented as follows:

\begin{code}
collect [] = []
collect ((x,y):t) = (x, y:[e2 |(e1, e2)<-t,e1 == x]): collect [(e1, e2) | (e1, e2) <- t, e1 /= x ]
\end{code}

According to \cite{agboola2015extensible}, this implementation of \texttt{collect} has a worst-case asymptotic time complexity of
O$(n^2)$.

\begin{definition}[Entity-event relation]
  A binary relation from entities in a triplestore to events in that triplestore
\end{definition}

The function \texttt{make\_image} creates an entity-event relation from a given event type and then converts it to an image using \texttt{collect}:

\begin{code}
  make_image et = collect [(subj, ev) | ev <- evs, subj <- getts_3 (ev, "subject","?") ]
    where evs = getts_1 ("?", "type",  et)
\end{code}

Transitive verbs were defined by {\em filtering} pairs in the image of the event
type that corresponds to the verb using the termphrase provided.  The only pairs remaining in the image are those
for which the termphrase predicate returns \texttt{True}.  An example is the
``join'' verb:

\begin{code}
  join tmph = [subj | (subj, evs) <- make_image "join_ev",
       tmph (concat [getts_3 (ev,  "object", "?") | ev <- evs])]
\end{code}

Prepositional phrases were defined through an extension of the above
mechanism.  Before passing an entity list to a termphrase, the events
those entities were drawn from would be first filtered through a series
of prepositions.

Prepositions were defined as a pair consisting of the name of a property
of an event and a termphrase.  Chained prepositional phrases were defined
as a list of prepositions.

An example chained prepositional phrase: \texttt{[("with\_implement", a
telescope), ("year", year "1877")]}

\texttt{join} could be modified to support prepositions as
follows:

\begin{code}
  joinâ€™ tmph preps = [subj | (subj, evs) <- make_image "join_ev", 
    tmph (concat [getts_3 (ev,"object","?") | ev <- evs,
      filter_ev ev preps])]
\end{code}

where \texttt{filter\_ev} is defined as follows \cite{frost2014denotational}:

\begin{code}
  filter_ev ev [] = True
  filter_ev ev (prep:list_of_preps) = ((snd (prep)) (getts_3 (ev,fst (prep),"?")))
                                      && filter_ev ev list_of_preps
\end{code}

\subsection{Haskell implementation for SPARQL}

Later, in \cite{agboola2015extensible}, the Haskell implementation was modified
to support SPARQL endpoints, with some efficiency improvements.  In particular, the asymptotic time complexity of the \texttt{collect} function was improved to O$(n$ log $n)$ time.

\section{Improvements over Original Semantics}

The improvements from the original semantics presented in \cite{frost2014demonstration} \cite{frostagboola2014} are detailed below.

\subsection{Multiple-property prepositions and terminology}

Prepositions were previously defined as a pair consisting of the name of a property of an event and a termphrase.  This meant that prepositions could
only refer to one property of an event, making prepositions such as ``in'', which could refer to either a location or a range in time, impossible to express.
To solve this, we extended the definition of preposition in our semantics.  First, some new terminology:

\begin{definition}[Property]
	A \texttt{predicate} of a triple in an event-based triplestore.
\end{definition}

For example, in the triple \texttt{(event1000, with\_implement, refractor\_telescope\_1)}, \texttt{with\_implement} is a property.  Since the triple belongs to \texttt{event1000}, we say that \texttt{with\_implement} is a property of \texttt{event1000}.  In general, there is no restriction on the number of entities of an event that share the same property.

\begin{definition}[Preposition]
	A pair consisting of a set of properties and a predicate.
\end{definition}

By using a set of properties rather than a single property as in the original semantics, we are able to support prepositions that could refer to multiple properties.
For example, the preposition \texttt{in'} in our semantics is defined as:

\begin{code}
	in' tmph = ({"location", "year"}, tmph)
\end{code}

When referring to the entities with property \texttt{prop} of an event, we are referring to the \texttt{objects} of the triples of the event that have the predicate \texttt{prop}.
We may use the phrase ``the \texttt{prop}s of an event'' as a shorthand for ``the entities with property \texttt{prop} of an event''.
For example, the \texttt{subjects}, \texttt{objects}, or \texttt{types} of an event are the entities with property \texttt{subject}, \texttt{object} or \texttt{type} of that event, respectively.

\subsection{Naming and definition of ``Images''}

Originally, transitive verbs were defined in terms of {\em images} \cite{frost2014denotational}.
In this Thesis, we use the term {\em function defined by the relation} instead of {\em image}, as {\em image} is a term that already exists throughout mathematics and has
a different meaning.

\begin{definition}[Function defined by the relation $r$]
	The function defined by the binary relation $r$ is the set $\{(x, image_x) : x $ is a member of the domain of $r$ and $image_x$ is the image of $x$ under $r\}$
\end{definition}

The function defined by a relation is referred to throughout this thesis by the shorthand {\em FDBR}.  It is represented with an association list in the Haskell code,
as {\em images} were represented in the original semantics.  The function defined by the relation $r$ is denoted with the syntax $FDBR(r)$.
We call an element $(x, image_x)$ in an FDBR an {\em FDBR-pair}.

We also define the {\em ENTEVPROP} relation.  Informally, {\em ENTEVPROP}$(evs, prop)$ is the entity-event relation in which the \texttt{prop}s of the events \texttt{evs} are related to the events that they belong to.

\begin{definition}[ENTEVPROP(evs, prop) relation]
	\[\text{ENTEVPROP(evs, prop) = }\{\text{(ent, ev) : ent } \in \text{ getts(ev, prop, ANY) \& ev} \in \text{evs} \}\]
\end{definition}

The {\em ENTEVPROP\_TYPE} relation is similar, accepting an event type as an argument instead of a set of events.
{\em ENTEVPROP\_TYPE}$(ev\_type, prop)$ obtains the set of events where the \texttt{type}s of those events are the desired event type.


\begin{definition}[ENTEVPROP\_TYPE(ev\_type, prop) relation]
	\begin{multline}
	\text{ENTEVPROP\_TYPE(ev\_type, prop) = ENTEVPROP(evs, prop)} \\ \text{where evs = getts(ANY, type, ev\_type)}
	\end{multline}
\end{definition}

In the original semantics, the \texttt{make\_trans} function could be defined as:

\begin{code}
	make_trans event_type = FDBR(ENTEVPROP_TYPE(event_type, "subject"))
\end{code}

These relations form the basis on which our new semantics are defined.


\subsection{Semantic consistency}

One goal of the new semantics is to unify concepts in the original semantics.  A significant refactoring was done in order to 
accomplish this task.

In the following section, {\em function currying} \cite{currying} is used to simplify the description of the semantics.
Briefly, a function $f$ with $n$ arguments can be {\em curried} into a chain of $n$ functions, each accepting one argument and returning the next function
in a chain, effectively ``fixing'' the current argument in the returned function.  If the end of the chain is reached, the value that $f$
would have produced had it been directly called with all $n$ arguments is returned.  This is a key feature of many functional programming languages \cite{haskell}.

We use the syntax $f x_1 x_2 .. x_n$ to denote a function or function call with $n$ arguments.  If this syntax is used
and only a partial number of arguments are provided, then a function of the remaining arguments is returned.  Otherwise,
this syntax is equivalent to $f(x_1, x_2, ..., x_n)$.

\subsubsection{Triplestore utility functions}

The \texttt{getts} functions are identical to how they were in \cite{frost2013event}, however
all other triplestore utility functions have been modified from their original definitions.
In particular, the functions \texttt{get\_subjs\_for\_event}, \texttt{get\_subjs\_for\_events},
\texttt{get\_subjs\_for\_event\_type}, and \texttt{get\_members} return FDBRs rather than entity lists.  They are defined as follows:

\texttt{get\_subjs\_for\_events evs = FDBR(ENTEVPROP(evs, "subject"))}

\texttt{get\_subjs\_for\_event ev = get\_subjs\_for\_events \{ev\}}

\texttt{get\_subjs\_for\_event\_type ev\_type = FDBR(ENTEVPROP\_TYPE(ev\_type, "subject"))}

The definition of \texttt{get\_members} is identical to the original except that it uses the new \texttt{get\_subjs\_for\_events} function.

By returning FDBRs, information about the entire entity-event relation is provided rather than only information about entities
belonging to those events.  This change simplifies the definitions of the triplestore utility functions and also makes their function
more uniform.


\subsubsection{Semantic functions}

All semantic functions have been modified to accept FDBRs and return FDBRs, with the exception of ``query'' functions
\texttt{whatobj}, \texttt{where'}, \texttt{how'}, \texttt{when'}, and \texttt{what}.

\texttt{what} and \texttt{whatobj} are differentiated to obtain the \texttt{subjects} and \texttt{objects} of FDBRs, respectively, with the
\texttt{objects} being obtained through the events in FDBR. 

\paragraph{Predicates}
Previously, predicates accepted arguments in the form of entity lists and returned boolean values.

In our new semantics, we modified the definition of predicates such that predicates accept FDBRs and return FDBRs.  A returned FDBR that is non-empty is 
considered to be \texttt{True}.  A returned FDBR that is empty is considered to be \texttt{False}.

\begin{definition}[Predicate]
	A function from FDBRs to FDBRs.
\end{definition}

Specifically, all predicates are now defined in terms of a function \texttt{intersect\_fdbr}.

\begin{definition}[intersect\_fdbr function]
	\begin{multline}
	\text{intersect\_fdbr fdbr1 fdbr2 = } \\ \{\text{(ent2, evs2) : (ent1, evs1) }\in \text{fdbr1 \& (ent2, evs2) } \in \text{fdbr2 \& ent1 = ent2}\}
	\end{multline}
\end{definition}

Briefly, this function performs the intersection of two FDBRs using the entity name in each FDBR-pair.  The events from the second FDBR are preserved
in the intersection, and the events from the first FDBR are discarded.  The reason it is defined this way is because when filtering, the FDBR being filtered
is the second argument to \texttt{intsersect\_fdbr}, and therefore those events should be preserved.  Furthermore, the events of the first argument
don't contribute anything to the result--often times, these are membership events, for instance in a termphrase like \texttt{a moon}.

With this in mind, determiners have been defined as follows:

\begin{equation*}
\begin{split}
\text{a nph vbph} = \text{intersect\_fdbr nph vbph} \\
\text{any nph vbph} = \text{a nph vbph}   \\
\text{the nph vbph} = \text{a nph vbph}  \\
\text{some nph vbph} = \text{a nph vbph}   \\
\text{an nph vbph} = \text{a nph vbph}   \\
\end{split}
\end{equation*}
	
\begin{equation*}
\begin{split}
\text{every}(\text{nph}, \text{vbph}) =
\begin{cases}
	\text{intersect\_fdbr}(\text{nph},\text{vbph}), \text{if nph\_entities } \subseteq \text{ vbph\_entities} \\
	\emptyset, \text{otherwise}
\end{cases} \\
\text{where} \\
\text{nph\_entities = map fst nph} \\
\text{vbph\_entities = map fst vbph} \\
\end{split}
\end{equation*}

\begin{equation*}
\begin{split}
\text{one}(\text{nph}, \text{vbph}) =
\begin{cases}
	\text{intersect\_fdbr}(\text{nph},\text{vbph}), \text{if } \left\vert\text{intersect\_fdbr}(\text{nph},\text{vbph})\right\vert = 1 \\
	\emptyset, \text{otherwise}
\end{cases} \\
\end{split}
\end{equation*}

\begin{equation*}
\begin{split}
\text{two}(\text{nph}, \text{vbph}) =
\begin{cases}
\text{intersect\_fdbr}(\text{nph},\text{vbph}), \text{if }\left\vert\text{intersect\_fdbr}(\text{nph},\text{vbph})\right\vert = 2 \\
\emptyset, \text{otherwise}
\end{cases} \\
\end{split}
\end{equation*}

\texttt{fst} is a function that returns the first component from in a pair.  The \texttt{map} function computes the image of a function $f$ over a set $s$.  
Therefore the function \texttt{map fst} obtains all of the entities in an FDBR.

This change was actually motivated by our changes to how prepositional phrases are handed in our semantics, and is the basis through which
``filtering'' occurs along preposition chains.

\paragraph{Transitive verbs}

In the original semantics, the function \texttt{make\_trans} was used to construct an FDBR out of an event type.

In our semantics, we distinguish between the active and passive voices of transitive verbs.  For example, in the sentence ``Hall discovered a moon'', the active voice is being used.
In the sentence ``A moon was discovered by Hall'', the passive voice is being used.  
We provide two functions, \texttt{make\_trans\_active'} and \texttt{make\_trans\_passive'} to construct an FDBR representing the active and passive voice of a transitive verb, respectfully.

\begin{code}
	make_trans_active'
	make_trans_passive'
\end{code}

\begin{equation*}
\begin{split}
\text{make\_trans\_active} = \text{make\_trans\_active' } \emptyset \\
\text{make\_trans\_passive} = \text{make\_trans\_passive' } \emptyset
\end{split}
\end{equation*}



These two functions

Therefore, both voices of transitive verbs are handled uniformly and transparently.


\paragraph{Adjectives, common nouns, and intransitive verbs}



In the original semantics, intransitive verbs

Adjectives, like common nouns, were defined as a set of entities.

Since common nouns are FDBRs rather than entity lists now due to how \texttt{get\_members} is defined, they can be handled in exactly
the same way that intransitive verbs are handled.

Adjectives were not demonstrated in the original semantics, however are easily accommodated using the \texttt{intersect\_fdbr} function.

For example: \texttt{a vaccuummous moon}



%TODO: rename getts_preimage
\begin{itemize}
	\item getts\_preimage
	\item All semantic functions and triplestore utility functions accept FDBRs as arguments and return FDBRs as results
\end{itemize}

\subsubsection{The use of `by' as a preposition}

%TODO: rename make\_inverted\_filtered\_relation
%TODO: newterm
One item of note is that in our semantics we treat the word ``by'', as in ``discovered by'', as a preposition.

We differentiate between the uses of active and passive voices for transitive verbs.  For passive verbs, the function
\texttt{make\_inverted\_filtered\_relation rel} is used to construct \texttt{FDBR(ENTEVPROP\_TYPE(rel, "object"))}.

Initially, the termphrase after ``by'' was applied to $FDBR(\texttt{relation\_})$ in order to filter FDBR-pairs for those matching
the termphrase.  However, this is exactly the same task that \texttt{filter\_ev} already performs when evaluating chains of prepositional phrases.
By letting \texttt{by tmph = (["subject"], tmph)}, we can include \texttt{by} directly in chains of prepositional phrases, simplifying the grammar
with no loss of functionality.  With this approach, ``by'' can appear anywhere in a chain of prepositions, for example ``in 1877 by hall'', instead
of needing to be directly next to the verb.


\subsection{The implicit `and' problem and the problem of `every'}

In the original semantics there were two problems with how prepositional phrases were implemented.

First, a query such as ``the sun is orbited by every planet'' would have returned \texttt{False} due to the way \texttt{filter\_ev} was implemented.

This was because in $FDBR($\texttt{orbit\_}$)$, where \texttt{orbit\_ = ENTEVPROP\_TYPE(orbit\_ev, object)}, the FDBR-pair for \texttt{sun} would have the form: \texttt{(sun, [event1000, event1001, ..., event1008])}, where each event would denote a separate \texttt{orbit} event corresponding to each planet that orbits the sun.  \texttt{filter\_ev} applied each preposition's termphrase to each event separately, meaning that no information provided by other events could be used by the predicate.  Hence \texttt{every planet} would have returned \texttt{False} for each individual event's associated \texttt{object}, and \texttt{filter\_ev} would have discarded the pair for \texttt{sun} in $FDBR($\texttt{orbit\_}$)$.  If there were one singular orbit event in which all of the planets were listed as orbiting the sun, then this query would have worked.  However, if there are properties unique to the planets being described in each orbit event, then it is not possible to describe all orbits in one singular event.  Therefore there was a need for a method to filter events in FDBRs that allowed termphrases to view the objects of {\em all} events in an FBDR-pair rather than just one.  This was fixed by modifying \texttt{filter\_ev} to first collect all of the relevant properties for each preposition from all events,  and then evaluating the termphrase over those properties.

Second, an implicit ``and'' was placed in between each preposition, transforming sentences such as ``who discovered something with two telescopes in 1914'' into ``who discovered something with two telescopes and in 1914''.

Although the above sentence is ambiguous in that it could be asking whether someone used two telescopes to discover one particular object, or whether
someone discovered potentially different objects with two telescopes, the asker most certainly did not intend for an implicit ``and'' to be inserted in between the prepositions.
The reason this happens is because in the original \texttt{filter\_ev} function, the event lists were not actually ``honed down'' before being passed to subsequent predicates in the preposition chain.

%TODO: PUREMATH
Both of these problems were solved by modifying \texttt{filter\_ev} as follows:

\begin{code}
filter_ev :: (TripleStore m) => m -> [([String], IO FDBR -> IO FDBR)] -> [Event] -> IO Bool
filter_ev _ [] _ = return True
filter_ev ev_data ((names,pred):list) evs = do
relevant_list <- mapM (\name -> getts_preimage ev_data name evs) names
res <- pred $ return $ concat $ relevant_list
let relevant_evs = List.nub $ concatMap snd res
if res /= [] then filter_ev ev_data list relevant_evs else return False
\end{code}

%TODO: NEWNOTATION/PUREMATH
Briefly, \texttt{filter\_ev} creates an FBDR out of the provided event list \texttt{evs} by using the \texttt{getts\_preimage} function
to ``pull out'' the desired properties from a list of events.  All of these are merged into one FDBR,
which the termphrase associated with the preposition is then evaluated on.  Termphrases always return only the elements of an FBDR that are ``relevant'',
as all termphrases are defined in terms of the function \texttt{intersect\_fdbr}, which behaves like a list intersection except for FDBRs.
Hence the resultant list, \texttt{res}, contains only the events relevant to the current preposition and can be used against the remaining prepositions, recursively, to ``hone down'' the relevant events on each preposition in the chain.

\section{Improvements over Original Haskell Implementations}

\subsection{Type safety}

The original semantics were implemented as {\em pure functions} in Haskell, which was acceptable for the in-program triplestores they were used on.

In \cite{agboola2015extensible}, the \texttt{getts\_*} functions were modified to retrieve triples from external SPARQL endpoints, enabling the original
semantics to work with SPARQL triplestores.  For SPARQL triplestores, however, the \texttt{getts\_*} functions as defined in \cite{agboola2015extensible} are not actually guaranteed to be referentially transparent. In particular, SPARQL triplestores are able to change over time with triples being potentially added, removed, or modified.
For example, consider the query ``which people discovered a moon that was discovered by a person''.
``people'' and ``person'' are synonyms in our semantics and therefore the same query would be performed twice.  If the SPARQL triplestore changed in between these evaluations,
then these queries could return different results, violating referential transparency.

The function \texttt{unsafeDupablePerformIO} was used in \cite{agboola2015extensible} to force Haskell to treat the \texttt{getts\_*} functions as pure functions
in order to maintain compatibility with the original semantics. The problem with \texttt{unsafeDupablePerformIO} is that it subverts the type system of Haskell.  Code that is built using it is therefore not on
solid theoretical ground within the constructs of the language, and surprising effects can occur as a result.  The use of \texttt{unsafeDupablePerformIO}, while
legitimate in some cases, is heavily discouraged within the Haskell community \cite{noUnsafePerformIO}.

In this Thesis, we chose a different approach to handling external triplestore queries by representing the triplestore functions and semantics in terms of {\em monadic functions}.
Briefly, monads in the Haskell programming language are types that are instances of the {\em Monad} typeclass that obey the
{\em monad laws} \cite{monadlaws}.  In Haskell, functions that are not {\em referentially transparent} are represented using computations in the monad \texttt{IO}, commonly referred to as the {\em IO monad}.  By expressing the semantics and triplestore functions monadically, we stay safely within the confines of Haskell's type system, avoiding
the need to use \texttt{unsafeDupablePerformIO} in order to perform queries to external triplestores as a result.  Another key benefit of this approach is that it preserves the compositional nature of the original semantics.

The semantics are defined in the IO monad currently, however if other monads were desired, only minimal changes would be required in order to accommodate
other instances of the Monad typeclass.  In the chapter {\em Future Work}, one potential application of this functionality is discussed.

\subsection{An generic interface to triplestores using a typeclass}

Typeclasses are used in Haskell to enable {\em ad-hoc polymorphism} in the definition of functions in the language.  This can be used
to provide generic interfaces to different types, without callers needing to be aware of the differences between those types.
We used this feature of the language to provide a generic interface for triplestores in the form of typeclass \texttt{TripleStore}.

\texttt{TripleStore m} subsumes the functionality that the \texttt{getts\_*} functions provided in the original semantics.

\begin{code}
class TripleStore m where
	getts_1 :: m -> (Event, String, String) -> IO [String]
	getts_2 :: m -> (Event, String, String) -> IO [String]
	getts_3 :: m -> (Event, String, String) -> IO [String]

	getts_fdbr :: m -> String -> String -> IO FDBR
	getts_fdbr ev_data ev_type entity_type = do
		evs <- getts_1 ev_data ("?", "type", ev_type)
		getts_preimage ev_data entity_type evs
		
	getts_preimage :: m -> String -> [Event] -> IO FDBR
	getts_preimage ev_data entity_type evs = do
		pairs <- liftM concat $ mapM (\ev -> do
		ents <- getts_3 ev_data (ev, entity_type,"?")
		return $ zip ents (repeat ev)) evs
		return $ collect pairs

	getts_members :: m -> String -> IO FDBR
	getts_members ev_data set = do
		evs_with_set_as_object <- getts_1 ev_data ("?", "object", set)
		evs_with_type_membership <- getts_1 ev_data ("?", "type", "membership")
		getts_preimage ev_data "subject" $ intersect evs_with_set_as_object evs_with_type_membership
\end{code}

First and foremost, the \texttt{getts\_*} functions defined in \texttt{TripleStore m} now properly return {\em IO actions}.
Three new functions are introduced, \texttt{getts\_preimage}, \texttt{getts\_fdbr}, and \texttt{getts\_members}.
\texttt{getts\_fdbr} serves the same purpose that \texttt{make\_image} had in the original semantics.

TODO: \texttt{getts\_members} behaves like \texttt{get\_members} in the original semantics, except...

TODO: \texttt{getts\_preimage} behaves like \texttt{getts\_fdbr}...

Only the three \texttt{getts\_*} functions must be defined for the new type of triplestore at minimum, however efficient implementations
of all functions in the typeclass may be provided if desired.  We provide a backend using a SPARQL endpoint as a triplestore using the
\texttt{SPARQLBackend} type and a backend for in-program triplestores using the \texttt{[Triple]} type as instances of \texttt{TripleStore}.




\subsection{Efficiency}

The \texttt{collect} function as defined in \cite{agboola2015extensible} used a key-value store from the \texttt{Data.Map.Lazy} module in Haskell to efficiently construct Images from relations represented as association lists.  Because all key-value pairs of the \texttt{Map} will eventually be traversed, in this Thesis the \texttt{Data.Map.Strict} module was used instead.  The asymptotic time complexity of both methods are identical, however the \texttt{Strict} version uses less memory and is slightly faster as it does not attempt to store partially evaluated areas of the Map as {\em thunks}.

%\begin{theorem}
%	\texttt{collect} is optimal.
%\end{theorem}

%Proof: Suppose a function \texttt{collect'} exists that converts a relation into an Image in faster than O($n$ lg $n$) time.

%Let $unsorted$ be an unsorted list whose list elements are an instance of the \texttt{Comparable} typeclass.
%That is, the list elements can be compared with one another using the comparison operators.

%Define the function \texttt{sort'} as follows:

%\begin{code}
%	sort' = uncollect . collect'
%	where
%	uncollect = map (\(ent, evs) -> map (\ev -> (ent, ev)) evs)
%\end{code}

\subsubsection{Efficiently constructing FDBRs from grouped association lists}
In addition, a new function, \texttt{condense}, has been created to efficiently construct $FDBR(r)$ such that $r$ is represented by an association list that is grouped according to the first element in each pair.

\begin{code}
	condense = map (\list -> (fst $ head list, map snd list)) . List.groupBy cmp
	where
	cmp x y = (fst x) == (fst y)
\end{code}

\begin{theorem}
	\texttt{condense} has $O(n)$ worst-case upper-bound asymptotic time complexity, with comparison on the first element in the association list pairs being the key operation.
\end{theorem}

Proof:

\texttt{cmp} is the function that compares two association list pairs by their first element.  

%\begin{proposition}
%	\texttt{cmp} has $O(1)$ worst-case upper-bound asymptotic time complexity, with comparison being the key operation.
%\end{proposition}

%Proof:

%In the Haskell standard library source code, \texttt{fst} is defined as follows \cite{hstdlib}:

%\begin{code}
%	fst (x,_) = x
%\end{code}

%This function has trivially $\theta(1)$ worst-case tight bound time complexity for any key operation.

%Since Haskell is a pass-by-reference language with lazy evaluation, this function will return in a constant amount of time regardless of the size of \texttt{x},
%as \texttt{x} will not be copied on return of the function.  Therefore \texttt{fst} has $\theta(1)$ worst-case tight bound time complexity.

%The operator \texttt{(==)} for the \texttt{String} type (triples are represented as 3-tuples of \texttt{Strings} in our code) has a worst-case upper bound time %complexity of O$(n)$, because in the worst case, both \texttt{Strings} being compared have length $n$ and are equal, forcing each character in both strings to be %evaluated and compared.

%Only one comparison on the first elements of the pairs \texttt{x} and \texttt{y} is performed for \texttt{cmp x y}.
%Therefore, the worst-case upper-bound asymptotic time complexity of \texttt{cmp} is O$(1)$.

%Since the $O(n)$ term dominates for large $n$, \texttt{cmp} therefore has a worst-case tight-bound asymptotic time complexity of $O(n)$. \qedsymbol

\begin{proposition}
	The function \texttt{List.groupBy cmp} has O$(n)$ worst-case upper-bound asymptotic time complexity, with comparisons on the elements of the input list using \texttt{cmp} being the key operation.
\end{proposition}

Proof:

In the Haskell standard library source code, \texttt{Data.List.groupBy} is defined as follows: \cite{hstdlib}:

\begin{code}
	groupBy _  []           =  []
	groupBy eq (x:xs)       =  (x:ys) : groupBy eq zs
	where (ys,zs) = span (eq x) xs
\end{code}

\texttt{span} is defined as follows \cite{hstdlib}:

\begin{code}
	span _ xs@[]            =  (xs, xs)
	span p xs@(x:xs')
	| p x          =  let (ys,zs) = span p xs' in (x:ys,zs)
	| otherwise    =  ([],xs)
\end{code}

%\begin{subproposition}
%	\texttt{span} has O$(n)$ worst case tight bound asymptotic time complexity, with evaluations of predicate \texttt{p} being the key operation.
%\end{subproposition}

%Proof:

%In the worst case, \texttt{p} will evaluate to \texttt{True} for all elements in the input list \texttt{xs}, forcing
%the evaluation of \texttt{span} on all suffixes of \texttt{xs}.  Since there are $n + 1$ suffixes of \texttt{xs}, 
%and \texttt{p} is evaluated for each suffix, it follows that $n + 1$ evaluations of \texttt{p} are performed.
%Therefore, \texttt{span} has a worst-case lower-bound asymptotic time complexity of O$(n + 1) = $O$(n)$. \qedsymbol

%--

Here, \text{eq = cmp} in \texttt{groupBy}, with \texttt{eq x = cmp x = p} being the predicate function used in \texttt{span}. %for elements of the list \text{(x:xs)}.

%The $0$th contiguous group of elements in a list \texttt{qs} according to a predicate \texttt{pred} is the longest prefix \texttt{pre} of \texttt{qs} where
%\texttt{pred} is \texttt{True} for all elements in \texttt{pre}.

%The $i$th contiguous group of elements in a list \texttt{qs} according to a predicate \texttt{pred} is the $0$th contiguous group of elements of
%the list obtained by removing all previous contiguous groups of elements from \texttt{qs}. 

%The $i$th contiguous group of elements in a list \texttt{qs} according to a predicate \texttt{pred} is the longest prefix \texttt{pre} of the list \texttt{rs}
%where \texttt{rs} is the list obtained by removing all previous contiguous groups of elements from \texttt{qs}, and \texttt{pred} is \texttt{True} for all elements
%of \texttt{pre}.

%A contiguous group of elements in a list \texttt{qs} under a predicate \texttt{pred} is a contiguous sublist of \texttt{qs} such that \texttt{pred}
%is \texttt{True} for all elements in the sublist.

%Let $m$ be the number of contiguous groups of elements in the list \texttt{(x:xs)}.

%Let $C$ be the list containing the number of elements in each contiguous group of elements in the list \texttt{(x:xs)}.  \texttt{C[i]} denotes the \texttt{i}th element in \texttt{C}.

Let $n$ denote the number of elements in \texttt{(x:xs)}.

The function \texttt{span} returns a partition \texttt{(ys, zs)} of the input list \texttt{xs}, where \texttt{ys} is the longest prefix of \texttt{xs} such that predicate \texttt{p} is \texttt{True} on all elements in the prefix, and \texttt{zs} are the remaining elements in \texttt{xs}.  It follows that \texttt{p} is evaluated at least $s$ times and at most $s + 1$ times, where $s$ is the length of \texttt{pre} (it will only be evaluated $s$ times if \texttt{pre = xs}).

By recursing into the second list returned by \texttt{span}, no previous elements of \texttt{(x:xs)} are revisited, and no elements are skipped, so \texttt{groupBy} partitions the input list \texttt{(x:xs)} into $m$ lists.  Call this partition \texttt{part}.  Note that the sum of the lengths of all lists in \texttt{part} is $n$.

For each list \texttt{i} in \texttt{part} except the last, \texttt{(length i - 1) + 1 = length i} comparisons will have been made (\texttt{groupBy} calls span on \texttt{xs}, not \texttt{x:xs}).  For the last list $last$ in \texttt{part}, \texttt{(length last - 1)} comparisons will have been made (the longest prefix is \texttt{xs} in this case).  Therefore, the total number of comparisons made can be expressed by:

\begin{code}
length part[0] + length part[1] + ... + length part[m - 2] + (length part[m - 1] - 1)
= (length part[0] + length part[1] + ... + length part[m - 1]) - 1
= n - 1
\end{code}

Hence, the worst-case upper-bound asymptotic time complexity of \texttt{List.groupBy cmp} is O$(n - 1)$ = O$(n)$, with comparisons using \texttt{cmp} being the key operation.
\qedsymbol

--

The lambda provided to \texttt{map} performs no comparisons and therefore has a worst-case tight-bound time complexity of
$\theta(1)$ with comparisons being the key operation.

The same applies to the composition function $\circ$.

--

%Let \texttt{groupPair list = (fst \$ head list, map snd list)}.

%\begin{proposition}
%	groupPair has O$(n)$ time complexity
%\end{proposition}

%Proof:

%\texttt{head list} has a worst-case tight-bound time complexity of $\theta(1)$.

%\texttt{snd} has a worst-case tight-bound time complexity of $\theta(1)$.

%\texttt{map} evaluates \texttt{snd} on every element of \texttt{list}, with
%a worst-case tight-bound time complexity of $\theta(n)*\theta(1) = \theta(n)$ .
%--

%\texttt{groupPair} and the lambda used in \texttt{map} used above have an identical definition and therefore have
%the same asymptotic time complexity.

The \texttt{map} function is composed with the \texttt{List.groupBy cmp} function to produce a new function:
\begin{code}
	\x -> map (\list -> (fst $ head list, map snd list)) (List.groupBy cmp x)
\end{code}

The \texttt{map} function evaluates the lambda over every list in the partition returned by (List.groupBy cmp x).  Since
neither the map, the lambda, nor the function composition perform any comparisons, they do not contribute to the number
of key operations performed.

Therefore the worst-case upper bound time complexity of \texttt{condense} is $O(1) + n*(O(1) + O(1)) + O(n) = O(n)$ with comparison on the first element in
the association list pairs (\texttt{cmp}) being the key operation.
$\blacksquare$

%Since \texttt{condense} has a worst-case tight bound asymptotic time complexity of $\theta(n)$, it is optimal. \qedsymbol 

\end{document}
